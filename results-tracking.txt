[initial knn]
additional features - rolling averages (for avg features) and totals (for total features) : 50, 150, 350

#score per row per day
a = getNeighborVals("same city", cityKnnModels[city][0].kneighbors(originalWeather), cityKnnModels[city][2]) / sameCityNumNeighbors * sameCityWeight
b = getNeighborVals("other city", cityKnnModels[city][1].kneighbors(originalWeather), cityKnnModels[city][3]) / otherCityNumNeighbors * otherCityWeight
c = getNeighborVals("fire", knnFires.kneighbors(originalWeather), fireData) / fireNumNeighbors * fireWeight
return a + b + c

#params
fireNumNeighbors, sameCityNumNeighbors, otherCityNumNeighbors = 20, 150, 7000
fireWeight, sameCityWeight, otherCityWeight = .35, .45, .2
#score
16.875511396843947/28

#scoring (for ONLY days with fires, position of city with fire in sorted list = fraction of points out of 1)
#(scoring explanation - if "city" had a fire on "day x", then if prediction list = ["city", ...] then 1 point, [..., "city"] then 1/58 points)
daysWithFires = {}
predictions = {}
dailyCityPreds = []
fireOnDate = False
for validationRow in queryResult:
	city = validationRow[0]
	rowDate = validationRow[1]

	if rowDate != date:
		if fireOnDate:
			predictions[date] = sorted(dailyCityPreds, key=lambda x: x[1], reverse=True)
		dailyCityPreds = []
		fireOnDate = False
		date = rowDate
		print(date)

	if validationRow[-4] == 1:
		fireOnDate = True
		if rowDate in daysWithFires:
			daysWithFires[rowDate].append(city)
		else:
			daysWithFires[rowDate] = [city]

	prob = topSimilar(validationRow)
	dailyCityPreds.append((city, prob))

score = 0
numFires = 0
print("\n\n\n")
print(daysWithFires)
print(predictions)
for key in daysWithFires:
	confirmedFires = daysWithFires[key]
	cityRankings = [i[0] for i in predictions[key]]
	for city in confirmedFires:
		numFires += 1
		score += (len(cityRankings) - cityRankings.index(city))/len(cityRankings)

print(f"\n{score}/{numFires}")